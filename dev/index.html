<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discretize Distributions.jl · Discretize Distributions</title><meta name="title" content="Discretize Distributions.jl · Discretize Distributions"/><meta property="og:title" content="Discretize Distributions.jl · Discretize Distributions"/><meta property="twitter:title" content="Discretize Distributions.jl · Discretize Distributions"/><meta name="description" content="Documentation for Discretize Distributions."/><meta property="og:description" content="Documentation for Discretize Distributions."/><meta property="twitter:description" content="Documentation for Discretize Distributions."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Discretize Distributions</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Discretize Distributions.jl</a><ul class="internal"><li><a class="tocitem" href="#Alternative-Packages"><span>Alternative Packages</span></a></li><li><a class="tocitem" href="#Limitations"><span>Limitations</span></a></li><li><a class="tocitem" href="#Future-Work"><span>Future Work</span></a></li><li><a class="tocitem" href="#API-Overview"><span>API Overview</span></a></li><li><a class="tocitem" href="#Mathematical-Details"><span>Mathematical Details</span></a></li><li><a class="tocitem" href="#Advanced-Usage"><span>Advanced Usage</span></a></li></ul></li><li><a class="tocitem" href="double_censoring/">Double Censoring</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Discretize Distributions.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Discretize Distributions.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GBarnsley/DiscretizeDistributions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GBarnsley/DiscretizeDistributions.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Discretize-Distributions.jl"><a class="docs-heading-anchor" href="#Discretize-Distributions.jl">Discretize Distributions.jl</a><a id="Discretize-Distributions.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Discretize-Distributions.jl" title="Permalink"></a></h1><p>A Julia package for converting continuous and discrete probability distributions into discrete representations with interval-based support using <code>IntervalArithmetic.jl</code>.</p><p>The package provides functions to discretize univariate distributions into <code>DiscreteNonParametric</code> distributions where the support consists of <code>IntervalArithmetic.Interval</code> objects. Each interval <code>[a, b)</code> represents a probability mass over that range, computed using the cumulative distribution function (CDF) for continuous distributions or aggregated probability mass function (PMF) for discrete distributions.</p><h2 id="Alternative-Packages"><a class="docs-heading-anchor" href="#Alternative-Packages">Alternative Packages</a><a id="Alternative-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Packages" title="Permalink"></a></h2><p>In julia, there are more lightweight discretizations. This package creates a new distribution that matches the discrete approximation (and so should be faster to simulate from) however this approach has more overhead than wrapping the existing pdf so these alternatives are recommended for fitting censored or discretized distributions (i.e. with <code>Turing</code> or some other package):</p><ul><li><code>pdf</code>/<code>logpdf</code>/<code>cdf</code>/<code>logcdf</code> methods from (StatsDiscretizations.jl)[https://github.com/nignatiadis/StatsDiscretizations.jl/tree/master]</li><li>(CensoredDistributions.jl)[https://github.com/EpiAware/CensoredDistributions.jl] which also has the ability for account for double censoring and truncation</li></ul><p>In R:</p><ul><li><code>distcrete</code> in the (discrete)[https://github.com/reconhub/distcrete] package</li><li><code>discretize</code> in the (actuar)[https://gitlab.com/vigou3/actuar] package</li></ul><h2 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h2><ul><li><strong>Finite support</strong>: Infinite distributions are truncated using quantile bounds (default 0.1% and 99.9%)</li><li><strong>Discrete distribution quirks</strong>: Discretizing already-discrete distributions has some limitations and edge cases</li><li><strong>Non-integer discrete values</strong>: Discrete distributions with non-integer support may behave unexpectedly</li><li><strong>Numeric means</strong>: Not all distributions have exact numeric means (i.e. truncated Gamma), these are needed for the <code>:unbiased</code> method so a backup numeric mean is calculated where possible using the trapezoid rule with <code>trapezoid_points</code>.</li></ul><h2 id="Future-Work"><a class="docs-heading-anchor" href="#Future-Work">Future Work</a><a id="Future-Work-1"></a><a class="docs-heading-anchor-permalink" href="#Future-Work" title="Permalink"></a></h2><ul><li>Develop better warnings for incompatible distributions</li><li>Support for multivariate distributions</li></ul><h2 id="API-Overview"><a class="docs-heading-anchor" href="#API-Overview">API Overview</a><a id="API-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#API-Overview" title="Permalink"></a></h2><p>The package provides three main <code>discretize</code> methods:</p><ol><li><strong>Fixed intervals</strong>: <code>discretize(dist, interval_width)</code> - Creates uniform intervals of specified width</li><li><strong>Custom boundaries</strong>: <code>discretize(dist, boundaries)</code> - Uses custom interval boundaries  </li><li><strong>Pre-constructed intervals</strong>: <code>discretize(dist, intervals)</code> - Uses pre-built <code>Interval</code> objects</li></ol><p>All methods return a <code>DiscreteNonParametric</code> distribution with support determined by the <code>method</code> parameter.</p><h3 id="Method-Parameter"><a class="docs-heading-anchor" href="#Method-Parameter">Method Parameter</a><a id="Method-Parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Parameter" title="Permalink"></a></h3><p>The <code>discretize</code> functions accept a <code>method</code> parameter that controls the output format:</p><ul><li><code>:interval</code> (default): Returns <code>IntervalArithmetic.Interval</code> objects as support points</li><li><code>:left_aligned</code>: Returns left endpoints of intervals as point masses</li><li><code>:centred</code>: Returns interval midpoints as point masses</li><li><code>:right_aligned</code>: Returns right endpoints of intervals as point masses</li><li><code>:unbiased</code>: Returns mean-preserving point masses (requires equal interval widths)</li></ul><pre><code class="language-julia hljs">normal_dist = Normal(0, 1)

# Different output methods
intervals = discretize(normal_dist, 0.5; method=:interval)        # Interval objects
left_points = discretize(normal_dist, 0.5; method=:left_aligned)  # Left endpoints
center_points = discretize(normal_dist, 0.5; method=:centred)     # Midpoints
right_points = discretize(normal_dist, 0.5; method=:right_aligned) # Right endpoints</code></pre><h4 id="Unbiased-Method"><a class="docs-heading-anchor" href="#Unbiased-Method">Unbiased Method</a><a id="Unbiased-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Unbiased-Method" title="Permalink"></a></h4><p>The <code>:unbiased</code> method provides mean-preserving discretization designed to minimize the difference between the original distribution&#39;s mean and the discretized distribution&#39;s mean. This is an implementation from the <code>discretize</code> function in the R package <code>actuar</code>.</p><pre><code class="language-julia hljs"># Unbiased discretization - preserves mean
normal_dist = Normal(2.0, 1.0)
unbiased_discrete = discretize(normal_dist, 0.2; method=:unbiased)

# Compare means
println(&quot;Original mean: &quot;, mean(normal_dist))      # 2.0
println(&quot;Unbiased mean: &quot;, mean(unbiased_discrete)) # ≈ 2.0
println(&quot;Centered mean: &quot;, mean(discretize(normal_dist, 0.2; method=:centred)))</code></pre><p>Both preserve the mean but the unbiased gives more control, supporting all values between [min, min + interval, ..., max] or [lower<em>quantile, lower</em>quantile + interval, ..., upper_quantile], where as centred (which maintains the mean) by necessity supports [min + interval/2, min + 3*interval/2, ..., max - interval/2]. However this requires that the mean of the given distribution be defined, and where an analytical approach is not defined (but the mean of the distribution isn&#39;t undefined in general) in <code>Distributions</code> an empirical mean is calculated.</p><h3 id="Working-with-Results"><a class="docs-heading-anchor" href="#Working-with-Results">Working with Results</a><a id="Working-with-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Results" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Distributions, DiscretizeDistributions, IntervalArithmetic

# Discretize a normal distribution
normal_dist = Normal(0, 1)
interval_dist = discretize(normal_dist, 0.5)

# The result has interval support
support(interval_dist)  # Vector of Interval{Float64} objects
probs(interval_dist)    # Corresponding probabilities

# Convert to point-based distributions
left_aligned = left_align_distribution(interval_dist)     # Use left endpoints
centered = centred_distribution(interval_dist)            # Use midpoints  
right_aligned = right_align_distribution(interval_dist)   # Use right endpoints</code></pre><h2 id="Mathematical-Details"><a class="docs-heading-anchor" href="#Mathematical-Details">Mathematical Details</a><a id="Mathematical-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Details" title="Permalink"></a></h2><h3 id="Continuous-Distributions"><a class="docs-heading-anchor" href="#Continuous-Distributions">Continuous Distributions</a><a id="Continuous-Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-Distributions" title="Permalink"></a></h3><p>For continuous distributions, discretisation computes probability masses using the cumulative distribution function (CDF):</p><p class="math-container">\[P(X&#39; ∈ [a_i, a_{i+1})) = F(a_{i+1}) - F(a_i)\]</p><p>where <code>F(x)</code> is the CDF of the continuous distribution <code>X</code>.</p><h3 id="Discrete-Distributions"><a class="docs-heading-anchor" href="#Discrete-Distributions">Discrete Distributions</a><a id="Discrete-Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-Distributions" title="Permalink"></a></h3><p>For discrete distributions, probability masses are aggregated over intervals using the probability mass function (PMF):</p><p class="math-container">\[P(X&#39; ∈ [a_i, a_{i+1})) = ∑_{k=⌈a_i⌉}^{⌊a_{i+1}⌋-1} P(X = k) + (P(X = ⌊a_i⌋) × (⌈a_i⌉ - a_i)) + (P(X = ⌊a_{i+1}⌋) × (a_{i+1} - ⌊a_{i+1}⌋))\]</p><p>All resulting discrete distributions are normalized to ensure probabilities sum to 1.</p><h2 id="Advanced-Usage"><a class="docs-heading-anchor" href="#Advanced-Usage">Advanced Usage</a><a id="Advanced-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Usage" title="Permalink"></a></h2><h3 id="Handling-Unbounded-Distributions"><a class="docs-heading-anchor" href="#Handling-Unbounded-Distributions">Handling Unbounded Distributions</a><a id="Handling-Unbounded-Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-Unbounded-Distributions" title="Permalink"></a></h3><p>For distributions with infinite support, control truncation with quantile bounds:</p><pre><code class="language-julia hljs"># Normal distribution - unbounded in both directions  
normal_dist = Normal(0, 1)
discrete_normal = discretize(normal_dist, 0.2; min_quantile=0.005, max_quantile=0.995)

# Exponential distribution - unbounded above
exp_dist = Exponential(1.0)  
discrete_exp = discretize(exp_dist, 0.1; max_quantile=0.99)

# Result includes infinite tail intervals
support(discrete_exp)  # [..., interval(4.5, 5.0), interval(5.0, ∞)]</code></pre><h3 id="Custom-Interval-Structures"><a class="docs-heading-anchor" href="#Custom-Interval-Structures">Custom Interval Structures</a><a id="Custom-Interval-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Interval-Structures" title="Permalink"></a></h3><p>Create non-uniform discretisations with custom boundaries:</p><pre><code class="language-julia hljs"># Fine resolution near zero, coarser elsewhere
custom_boundaries = [-5.0, -2.0, -1.0, -0.5, 0.0, 0.5, 1.0, 2.0, 5.0]
discrete_custom = discretize(Normal(0, 1), custom_boundaries)

# Results in intervals: [(-∞,-5], [-5,-2], [-2,-1], ..., [5,∞)]
length(support(discrete_custom))  # 10 intervals (8 from boundaries + 2 infinite tails)</code></pre><h3 id="Working-with-Pre-constructed-Intervals"><a class="docs-heading-anchor" href="#Working-with-Pre-constructed-Intervals">Working with Pre-constructed Intervals</a><a id="Working-with-Pre-constructed-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Pre-constructed-Intervals" title="Permalink"></a></h3><p>For advanced use cases, you can provide pre-constructed <code>IntervalArithmetic.Interval</code> objects:</p><pre><code class="language-julia hljs">using IntervalArithmetic

# Create custom intervals with specific properties
intervals = [
    interval(-2.0, -1.0),    # Standard interval
    interval(-1.0, 0.0),     # Adjacent interval
    interval(0.0, 2.0),      # Wider interval
    interval(2.0, Inf)       # Semi-infinite interval
]

# Discretize using these intervals
normal_dist = Normal(0, 1)
discrete_custom = discretize(normal_dist, intervals)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiscretizeDistributions.discretize" href="#DiscretizeDistributions.discretize"><code>DiscretizeDistributions.discretize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretize(dist::Distributions.UnivariateDistribution, interval::Real;
           method=:interval, min_quantile=0.001, max_quantile=0.999)</code></pre><p>Discretize a univariate distribution into a discrete distribution using fixed intervals.</p><p>This function converts a univariate distribution into a discrete one by dividing the distribution&#39;s support into intervals of fixed width and computing the probability mass in each interval.</p><p><strong>Arguments</strong></p><ul><li><code>dist::Distributions.UnivariateDistribution</code>: The distribution to discretize (continuous or discrete)</li><li><code>interval::Real</code>: The width of each discretisation interval</li><li><code>method::Symbol=:interval</code>: Method for representing the output distribution<ul><li><code>:interval</code> (default): Return <code>IntervalArithmetic.Interval</code> objects as support</li><li><code>:left_aligned</code>: Convert intervals to left-aligned point values</li><li><code>:centred</code>: Convert intervals to centered point values</li><li><code>:right_aligned</code>: Convert intervals to right-aligned point values</li><li><code>:unbiased</code>: Return unbiased point estimates (requires equal interval widths), designed such that the means match, see <code>discretize</code> from the R package <code>actuar</code></li></ul></li><li><code>min_quantile=0.001</code>: Lower quantile bound for unbounded distributions</li><li><code>max_quantile=0.999</code>: Upper quantile bound for unbounded distributions</li><li><code>trapezoid_points::Int=10000</code>: Number of points for numerical integration of the mean (when needed)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiscreteNonParametric</code>: Discrete distribution with support determined by the method parameter</li></ul><p><strong>Details</strong></p><p>For bounded distributions, the natural bounds are used. For unbounded distributions, the bounds are determined using the specified quantiles. The probability mass in each interval is computed using the CDF for continuous distributions or a pseudo-CDF for discrete distributions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions, DiscretizeDistributions, IntervalArithmetic

# Discretize a normal distribution with interval width 0.5
normal_dist = Normal(0, 1)

# Different output methods
discrete_intervals = discretize(normal_dist, 0.5)                        # Intervals (default)
discrete_left = discretize(normal_dist, 0.5; method=:left_aligned)      # Left endpoints
discrete_center = discretize(normal_dist, 0.5; method=:centred)         # Midpoints
discrete_right = discretize(normal_dist, 0.5; method=:right_aligned)    # Right endpoints

# Compare means (centered method typically closest to original)
println(&quot;Original mean: &quot;, mean(normal_dist))
println(&quot;Centered discretization mean: &quot;, mean(discrete_center))

# Discretize a discrete distribution
poisson_dist = Poisson(3.0)
discrete_poisson = discretize(poisson_dist, 2; method=:centred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DiscretizeDistributions.jl/blob/4648c0bd7ec06eafd571cb77444f97ae88430b16/src/univariate.jl#L105-L156">source</a></section><section><div><pre><code class="language-julia hljs">discretize(dist::Distributions.UnivariateDistribution, interval::AbstractVector; method=:interval)</code></pre><p>Discretize a univariate distribution using custom interval boundaries.</p><p>This function converts a univariate distribution into a discrete one using user-specified interval boundaries. The resulting distribution represents the probability mass in each interval.</p><p><strong>Arguments</strong></p><ul><li><code>dist::Distributions.UnivariateDistribution</code>: The distribution to discretize</li><li><code>interval::AbstractVector</code>: Vector of interval boundaries (will be sorted automatically)</li><li><code>method::Symbol=:interval</code>: Method for representing the output distribution<ul><li><code>:interval</code> (default): Return <code>IntervalArithmetic.Interval</code> objects as support</li><li><code>:left_aligned</code>: Convert intervals to left-aligned point values</li><li><code>:centred</code>: Convert intervals to centered point values</li><li><code>:right_aligned</code>: Convert intervals to right-aligned point values</li><li><code>:unbiased</code>: Return unbiased point estimates (requires equal interval widths), designed such that the means match, see <code>discretize</code> from the R package <code>actuar</code></li></ul></li><li><code>trapezoid_points::Int=10000</code>: Number of points for numerical integration of the mean (when needed)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiscreteNonParametric</code>: Discrete distribution with support determined by the method parameter</li></ul><p><strong>Details</strong></p><p>The input interval vector is automatically sorted and combined with distribution bounds. Probability masses are computed using the CDF for continuous distributions or pseudo-CDF for discrete distributions. The resulting distribution represents probability masses over intervals <code>[a_i, a_{i+1})</code>.</p><p>For the <code>:unbiased</code> method with unequal intervals, the function will warn and fall back to <code>:centred</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions, DiscretizeDistributions, IntervalArithmetic

# Discretize using custom intervals
normal_dist = Normal(5, 2)
custom_intervals = [0.0, 2.0, 4.0, 6.0, 8.0, 10.0]

# Different output methods
discrete_intervals = discretize(normal_dist, custom_intervals)                      # Intervals
discrete_left = discretize(normal_dist, custom_intervals; method=:left_aligned)    # Left points
discrete_center = discretize(normal_dist, custom_intervals; method=:centred)       # Midpoints
discrete_right = discretize(normal_dist, custom_intervals; method=:right_aligned)  # Right points

# Support: intervals like [interval(-∞, 0.0), interval(0.0, 2.0), ..., interval(10.0, ∞)]

# Discrete distribution with custom intervals
poisson_dist = Poisson(3.0)
discrete_poisson = discretize(poisson_dist, [0.5, 2, 4, 6, 8, 10]; method=:centred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DiscretizeDistributions.jl/blob/4648c0bd7ec06eafd571cb77444f97ae88430b16/src/univariate.jl#L165-L215">source</a></section><section><div><pre><code class="language-julia hljs">discretize(dist::Distributions.UnivariateDistribution,
           interval::AbstractVector{IntervalArithmetic.Interval{X}}; method=:interval) where X &lt;: Real</code></pre><p>Discretize a univariate distribution using pre-constructed interval objects.</p><p>This function converts a univariate distribution into a discrete one using user-specified <code>IntervalArithmetic.Interval</code> objects. This is the core discretization method that all other <code>discretize</code> methods ultimately call.</p><p><strong>Arguments</strong></p><ul><li><code>dist::Distributions.UnivariateDistribution</code>: The distribution to discretize</li><li><code>interval::AbstractVector{IntervalArithmetic.Interval{X}}</code>: Vector of pre-constructed intervals</li><li><code>method::Symbol=:interval</code>: Method for representing the output distribution<ul><li><code>:interval</code> (default): Return intervals as support points</li><li><code>:left_aligned</code>: Convert intervals to left-aligned point values</li><li><code>:centred</code>: Convert intervals to centered point values</li><li><code>:right_aligned</code>: Convert intervals to right-aligned point values</li><li><code>:unbiased</code>: Return unbiased point estimates (requires equal interval widths), designed such that the means match, see <code>discretize</code> from the R package <code>actuar</code></li></ul></li><li><code>trapezoid_points::Int=10000</code>: Number of points for numerical integration of the mean (when needed)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiscreteNonParametric</code>: Discrete distribution with support determined by the method parameter</li></ul><p><strong>Details</strong></p><p>This method computes probability masses directly using the interval boundaries. For each interval <code>[a, b]</code>, the probability is computed as <code>cdf(dist, b) - cdf(dist, a)</code>. The resulting probabilities are normalized to sum to 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions, DiscretizeDistributions, IntervalArithmetic

# Create intervals manually
intervals = [interval(-1.0, 0.0), interval(0.0, 1.0), interval(1.0, 2.0)]

# Discretize using these intervals with different methods
normal_dist = Normal(0, 1)
discrete_intervals = discretize(normal_dist, intervals)                      # Intervals
discrete_centered = discretize(normal_dist, intervals; method=:centred)      # Midpoints
discrete_left = discretize(normal_dist, intervals; method=:left_aligned)     # Left endpoints

# Each method gives the same probabilities but different support representations</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DiscretizeDistributions.jl/blob/4648c0bd7ec06eafd571cb77444f97ae88430b16/src/univariate.jl#L235-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiscretizeDistributions.left_align_distribution" href="#DiscretizeDistributions.left_align_distribution"><code>DiscretizeDistributions.left_align_distribution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_align_distribution(dist::Distributions.DiscreteNonParametric{IntervalArithmetic.Interval{T}, ...})</code></pre><p>Convert an interval-based discrete distribution to a left-aligned point-based distribution.</p><p>This function takes a discrete distribution with interval support and creates a new distribution where each support point is positioned at the left endpoint (infimum) of the corresponding interval. Infinite intervals are automatically removed before conversion.</p><p><strong>Arguments</strong></p><ul><li><code>dist::DiscreteNonParametric{Interval{T}, ...}</code>: Input discrete distribution with interval support</li></ul><p><strong>Returns</strong></p><ul><li><code>DiscreteNonParametric{T, ...}</code>: New distribution with left-aligned point support</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions, DiscretizeDistributions, IntervalArithmetic

# Create an interval-based distribution
intervals = [interval(0.0, 1.0), interval(1.0, 2.0), interval(2.0, 3.0)]
probs = [0.3, 0.4, 0.3]
interval_dist = DiscreteNonParametric(intervals, probs, check_args=false)

# Convert to left-aligned points
left_aligned = left_align_distribution(interval_dist)
# Support becomes [0.0, 1.0, 2.0] (left endpoints of intervals)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DiscretizeDistributions.jl/blob/4648c0bd7ec06eafd571cb77444f97ae88430b16/src/utility.jl#L70-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiscretizeDistributions.centred_distribution" href="#DiscretizeDistributions.centred_distribution"><code>DiscretizeDistributions.centred_distribution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centred_distribution(dist::Distributions.DiscreteNonParametric{IntervalArithmetic.Interval{T}, ...})</code></pre><p>Convert an interval-based discrete distribution to a centered point-based distribution.</p><p>This function takes a discrete distribution with interval support and creates a new distribution where each support point is positioned at the center (midpoint) of the corresponding interval. Infinite intervals are automatically removed before conversion.</p><p><strong>Arguments</strong></p><ul><li><code>dist::DiscreteNonParametric{Interval{T}, ...}</code>: Input discrete distribution with interval support</li></ul><p><strong>Returns</strong></p><ul><li><code>DiscreteNonParametric{T, ...}</code>: New distribution with centered point support</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions, DiscretizeDistributions, IntervalArithmetic

# Create an interval-based distribution
intervals = [interval(0.0, 1.0), interval(1.0, 2.0), interval(2.0, 3.0)]
probs = [0.3, 0.4, 0.3]
interval_dist = DiscreteNonParametric(intervals, probs, check_args=false)

# Convert to centered points
centered = centred_distribution(interval_dist)
# Support becomes [0.5, 1.5, 2.5] (midpoints of intervals)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DiscretizeDistributions.jl/blob/4648c0bd7ec06eafd571cb77444f97ae88430b16/src/utility.jl#L26-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiscretizeDistributions.right_align_distribution" href="#DiscretizeDistributions.right_align_distribution"><code>DiscretizeDistributions.right_align_distribution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_align_distribution(dist::Distributions.DiscreteNonParametric{IntervalArithmetic.Interval{T}, ...})</code></pre><p>Convert an interval-based discrete distribution to a right-aligned point-based distribution.</p><p>This function takes a discrete distribution with interval support and creates a new distribution where each support point is positioned at the right endpoint (supremum) of the corresponding interval. Infinite intervals are automatically removed before conversion.</p><p><strong>Arguments</strong></p><ul><li><code>dist::DiscreteNonParametric{Interval{T}, ...}</code>: Input discrete distribution with interval support</li></ul><p><strong>Returns</strong></p><ul><li><code>DiscreteNonParametric{T, ...}</code>: New distribution with right-aligned point support</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions, DiscretizeDistributions, IntervalArithmetic

# Create an interval-based distribution
intervals = [interval(0.0, 1.0), interval(1.0, 2.0), interval(2.0, 3.0)]
probs = [0.3, 0.4, 0.3]
interval_dist = DiscreteNonParametric(intervals, probs, check_args=false)

# Convert to right-aligned points
right_aligned = right_align_distribution(interval_dist)
# Support becomes [1.0, 2.0, 3.0] (right endpoints of intervals)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DiscretizeDistributions.jl/blob/4648c0bd7ec06eafd571cb77444f97ae88430b16/src/utility.jl#L113-L141">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="double_censoring/">Double Censoring »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 29 September 2025 13:17">Monday 29 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
