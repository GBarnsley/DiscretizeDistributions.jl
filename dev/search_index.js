var documenterSearchIndex = {"docs":
[{"location":"#Discretize-Distributions.jl","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"A Julia package for converting continuous and discrete probability distributions into discrete representations with interval-based support using IntervalArithmetic.jl.","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"The package provides functions to discretize univariate distributions into DiscreteNonParametric distributions where the support consists of IntervalArithmetic.Interval objects. Each interval [a, b) represents a probability mass over that range, computed using the cumulative distribution function (CDF) for continuous distributions or aggregated probability mass function (PMF) for discrete distributions.","category":"page"},{"location":"#Alternative-Packages","page":"Discretize Distributions.jl","title":"Alternative Packages","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"In julia, there are more lightweight discretizations. This package creates a new distribution that matches the discrete approximation (and so should be faster to simulate from) however this approach has more overhead than wrapping the existing pdf so these alternatives are recommended for fitting censored or discretized distributions (i.e. with Turing or some other package):","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"pdf/logpdf/cdf/logcdf methods from (StatsDiscretizations.jl)[https://github.com/nignatiadis/StatsDiscretizations.jl/tree/master]\n(CensoredDistributions.jl)[https://github.com/EpiAware/CensoredDistributions.jl] which also has the ability for account for double censoring and truncation","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"In R:","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"distcrete in the (discrete)[https://github.com/reconhub/distcrete] package\ndiscretize in the (actuar)[https://gitlab.com/vigou3/actuar] package","category":"page"},{"location":"#Limitations","page":"Discretize Distributions.jl","title":"Limitations","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"Finite support: Infinite distributions are truncated using quantile bounds (default 0.1% and 99.9%)\nDiscrete distribution quirks: Discretizing already-discrete distributions has some limitations and edge cases\nNon-integer discrete values: Discrete distributions with non-integer support may behave unexpectedly\nNumeric means: Not all distributions have exact numeric means (i.e. truncated Gamma), these are needed for the :unbiased method so a backup numeric mean is calculated where possible using the trapezoid rule with trapezoid_points.","category":"page"},{"location":"#Future-Work","page":"Discretize Distributions.jl","title":"Future Work","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"Develop better warnings for incompatible distributions\nSupport for multivariate distributions","category":"page"},{"location":"#API-Overview","page":"Discretize Distributions.jl","title":"API Overview","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"The package provides three main discretize methods:","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"Fixed intervals: discretize(dist, interval_width) - Creates uniform intervals of specified width\nCustom boundaries: discretize(dist, boundaries) - Uses custom interval boundaries  \nPre-constructed intervals: discretize(dist, intervals) - Uses pre-built Interval objects","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"All methods return a DiscreteNonParametric distribution with support determined by the method parameter.","category":"page"},{"location":"#Method-Parameter","page":"Discretize Distributions.jl","title":"Method Parameter","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"The discretize functions accept a method parameter that controls the output format:","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":":interval (default): Returns IntervalArithmetic.Interval objects as support points\n:left_aligned: Returns left endpoints of intervals as point masses\n:centred: Returns interval midpoints as point masses\n:right_aligned: Returns right endpoints of intervals as point masses\n:unbiased: Returns mean-preserving point masses (requires equal interval widths)","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"normal_dist = Normal(0, 1)\n\n# Different output methods\nintervals = discretize(normal_dist, 0.5; method=:interval)        # Interval objects\nleft_points = discretize(normal_dist, 0.5; method=:left_aligned)  # Left endpoints\ncenter_points = discretize(normal_dist, 0.5; method=:centred)     # Midpoints\nright_points = discretize(normal_dist, 0.5; method=:right_aligned) # Right endpoints","category":"page"},{"location":"#Unbiased-Method","page":"Discretize Distributions.jl","title":"Unbiased Method","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"The :unbiased method provides mean-preserving discretization designed to minimize the difference between the original distribution's mean and the discretized distribution's mean. This is an implementation from the discretize function in the R package actuar.","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"# Unbiased discretization - preserves mean\nnormal_dist = Normal(2.0, 1.0)\nunbiased_discrete = discretize(normal_dist, 0.2; method=:unbiased)\n\n# Compare means\nprintln(\"Original mean: \", mean(normal_dist))      # 2.0\nprintln(\"Unbiased mean: \", mean(unbiased_discrete)) # ≈ 2.0\nprintln(\"Centered mean: \", mean(discretize(normal_dist, 0.2; method=:centred)))","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"Both preserve the mean but the unbiased gives more control, supporting all values between [min, min + interval, ..., max] or [lowerquantile, lowerquantile + interval, ..., upper_quantile], where as centred (which maintains the mean) by necessity supports [min + interval/2, min + 3*interval/2, ..., max - interval/2]. However this requires that the mean of the given distribution be defined, and where an analytical approach is not defined (but the mean of the distribution isn't undefined in general) in Distributions an empirical mean is calculated.","category":"page"},{"location":"#Working-with-Results","page":"Discretize Distributions.jl","title":"Working with Results","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"using Distributions, DiscretizeDistributions, IntervalArithmetic\n\n# Discretize a normal distribution\nnormal_dist = Normal(0, 1)\ninterval_dist = discretize(normal_dist, 0.5)\n\n# The result has interval support\nsupport(interval_dist)  # Vector of Interval{Float64} objects\nprobs(interval_dist)    # Corresponding probabilities\n\n# Convert to point-based distributions\nleft_aligned = left_align_distribution(interval_dist)     # Use left endpoints\ncentered = centred_distribution(interval_dist)            # Use midpoints  \nright_aligned = right_align_distribution(interval_dist)   # Use right endpoints","category":"page"},{"location":"#Mathematical-Details","page":"Discretize Distributions.jl","title":"Mathematical Details","text":"","category":"section"},{"location":"#Continuous-Distributions","page":"Discretize Distributions.jl","title":"Continuous Distributions","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"For continuous distributions, discretisation computes probability masses using the cumulative distribution function (CDF):","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"P(X  a_i a_i+1)) = F(a_i+1) - F(a_i)","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"where F(x) is the CDF of the continuous distribution X.","category":"page"},{"location":"#Discrete-Distributions","page":"Discretize Distributions.jl","title":"Discrete Distributions","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"For discrete distributions, probability masses are aggregated over intervals using the probability mass function (PMF):","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"P(X  a_i a_i+1)) = _k=a_i^a_i+1-1 P(X = k) + (P(X = a_i)  (a_i - a_i)) + (P(X = a_i+1)  (a_i+1 - a_i+1))","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"All resulting discrete distributions are normalized to ensure probabilities sum to 1.","category":"page"},{"location":"#Advanced-Usage","page":"Discretize Distributions.jl","title":"Advanced Usage","text":"","category":"section"},{"location":"#Handling-Unbounded-Distributions","page":"Discretize Distributions.jl","title":"Handling Unbounded Distributions","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"For distributions with infinite support, control truncation with quantile bounds:","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"# Normal distribution - unbounded in both directions  \nnormal_dist = Normal(0, 1)\ndiscrete_normal = discretize(normal_dist, 0.2; min_quantile=0.005, max_quantile=0.995)\n\n# Exponential distribution - unbounded above\nexp_dist = Exponential(1.0)  \ndiscrete_exp = discretize(exp_dist, 0.1; max_quantile=0.99)\n\n# Result includes infinite tail intervals\nsupport(discrete_exp)  # [..., interval(4.5, 5.0), interval(5.0, ∞)]","category":"page"},{"location":"#Custom-Interval-Structures","page":"Discretize Distributions.jl","title":"Custom Interval Structures","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"Create non-uniform discretisations with custom boundaries:","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"# Fine resolution near zero, coarser elsewhere\ncustom_boundaries = [-5.0, -2.0, -1.0, -0.5, 0.0, 0.5, 1.0, 2.0, 5.0]\ndiscrete_custom = discretize(Normal(0, 1), custom_boundaries)\n\n# Results in intervals: [(-∞,-5], [-5,-2], [-2,-1], ..., [5,∞)]\nlength(support(discrete_custom))  # 10 intervals (8 from boundaries + 2 infinite tails)","category":"page"},{"location":"#Working-with-Pre-constructed-Intervals","page":"Discretize Distributions.jl","title":"Working with Pre-constructed Intervals","text":"","category":"section"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"For advanced use cases, you can provide pre-constructed IntervalArithmetic.Interval objects:","category":"page"},{"location":"","page":"Discretize Distributions.jl","title":"Discretize Distributions.jl","text":"using IntervalArithmetic\n\n# Create custom intervals with specific properties\nintervals = [\n    interval(-2.0, -1.0),    # Standard interval\n    interval(-1.0, 0.0),     # Adjacent interval\n    interval(0.0, 2.0),      # Wider interval\n    interval(2.0, Inf)       # Semi-infinite interval\n]\n\n# Discretize using these intervals\nnormal_dist = Normal(0, 1)\ndiscrete_custom = discretize(normal_dist, intervals)","category":"page"},{"location":"#DiscretizeDistributions.discretize","page":"Discretize Distributions.jl","title":"DiscretizeDistributions.discretize","text":"discretize(dist::Distributions.UnivariateDistribution, interval::Real;\n           method=:interval, min_quantile=0.001, max_quantile=0.999)\n\nDiscretize a univariate distribution into a discrete distribution using fixed intervals.\n\nThis function converts a univariate distribution into a discrete one by dividing the distribution's support into intervals of fixed width and computing the probability mass in each interval.\n\nArguments\n\ndist::Distributions.UnivariateDistribution: The distribution to discretize (continuous or discrete)\ninterval::Real: The width of each discretisation interval\nmethod::Symbol=:interval: Method for representing the output distribution\n:interval (default): Return IntervalArithmetic.Interval objects as support\n:left_aligned: Convert intervals to left-aligned point values\n:centred: Convert intervals to centered point values\n:right_aligned: Convert intervals to right-aligned point values\n:unbiased: Return unbiased point estimates (requires equal interval widths), designed such that the means match, see discretize from the R package actuar\nmin_quantile=0.001: Lower quantile bound for unbounded distributions\nmax_quantile=0.999: Upper quantile bound for unbounded distributions\ntrapezoid_points::Int=10000: Number of points for numerical integration of the mean (when needed)\n\nReturns\n\nDiscreteNonParametric: Discrete distribution with support determined by the method parameter\n\nDetails\n\nFor bounded distributions, the natural bounds are used. For unbounded distributions, the bounds are determined using the specified quantiles. The probability mass in each interval is computed using the CDF for continuous distributions or a pseudo-CDF for discrete distributions.\n\nExamples\n\nusing Distributions, DiscretizeDistributions, IntervalArithmetic\n\n# Discretize a normal distribution with interval width 0.5\nnormal_dist = Normal(0, 1)\n\n# Different output methods\ndiscrete_intervals = discretize(normal_dist, 0.5)                        # Intervals (default)\ndiscrete_left = discretize(normal_dist, 0.5; method=:left_aligned)      # Left endpoints\ndiscrete_center = discretize(normal_dist, 0.5; method=:centred)         # Midpoints\ndiscrete_right = discretize(normal_dist, 0.5; method=:right_aligned)    # Right endpoints\n\n# Compare means (centered method typically closest to original)\nprintln(\"Original mean: \", mean(normal_dist))\nprintln(\"Centered discretization mean: \", mean(discrete_center))\n\n# Discretize a discrete distribution\npoisson_dist = Poisson(3.0)\ndiscrete_poisson = discretize(poisson_dist, 2; method=:centred)\n\n\n\n\n\ndiscretize(dist::Distributions.UnivariateDistribution, interval::AbstractVector; method=:interval)\n\nDiscretize a univariate distribution using custom interval boundaries.\n\nThis function converts a univariate distribution into a discrete one using user-specified interval boundaries. The resulting distribution represents the probability mass in each interval.\n\nArguments\n\ndist::Distributions.UnivariateDistribution: The distribution to discretize\ninterval::AbstractVector: Vector of interval boundaries (will be sorted automatically)\nmethod::Symbol=:interval: Method for representing the output distribution\n:interval (default): Return IntervalArithmetic.Interval objects as support\n:left_aligned: Convert intervals to left-aligned point values\n:centred: Convert intervals to centered point values\n:right_aligned: Convert intervals to right-aligned point values\n:unbiased: Return unbiased point estimates (requires equal interval widths), designed such that the means match, see discretize from the R package actuar\ntrapezoid_points::Int=10000: Number of points for numerical integration of the mean (when needed)\n\nReturns\n\nDiscreteNonParametric: Discrete distribution with support determined by the method parameter\n\nDetails\n\nThe input interval vector is automatically sorted and combined with distribution bounds. Probability masses are computed using the CDF for continuous distributions or pseudo-CDF for discrete distributions. The resulting distribution represents probability masses over intervals [a_i, a_{i+1}).\n\nFor the :unbiased method with unequal intervals, the function will warn and fall back to :centred.\n\nExamples\n\nusing Distributions, DiscretizeDistributions, IntervalArithmetic\n\n# Discretize using custom intervals\nnormal_dist = Normal(5, 2)\ncustom_intervals = [0.0, 2.0, 4.0, 6.0, 8.0, 10.0]\n\n# Different output methods\ndiscrete_intervals = discretize(normal_dist, custom_intervals)                      # Intervals\ndiscrete_left = discretize(normal_dist, custom_intervals; method=:left_aligned)    # Left points\ndiscrete_center = discretize(normal_dist, custom_intervals; method=:centred)       # Midpoints\ndiscrete_right = discretize(normal_dist, custom_intervals; method=:right_aligned)  # Right points\n\n# Support: intervals like [interval(-∞, 0.0), interval(0.0, 2.0), ..., interval(10.0, ∞)]\n\n# Discrete distribution with custom intervals\npoisson_dist = Poisson(3.0)\ndiscrete_poisson = discretize(poisson_dist, [0.5, 2, 4, 6, 8, 10]; method=:centred)\n\n\n\n\n\ndiscretize(dist::Distributions.UnivariateDistribution,\n           interval::AbstractVector{IntervalArithmetic.Interval{X}}; method=:interval) where X <: Real\n\nDiscretize a univariate distribution using pre-constructed interval objects.\n\nThis function converts a univariate distribution into a discrete one using user-specified IntervalArithmetic.Interval objects. This is the core discretization method that all other discretize methods ultimately call.\n\nArguments\n\ndist::Distributions.UnivariateDistribution: The distribution to discretize\ninterval::AbstractVector{IntervalArithmetic.Interval{X}}: Vector of pre-constructed intervals\nmethod::Symbol=:interval: Method for representing the output distribution\n:interval (default): Return intervals as support points\n:left_aligned: Convert intervals to left-aligned point values\n:centred: Convert intervals to centered point values\n:right_aligned: Convert intervals to right-aligned point values\n:unbiased: Return unbiased point estimates (requires equal interval widths), designed such that the means match, see discretize from the R package actuar\ntrapezoid_points::Int=10000: Number of points for numerical integration of the mean (when needed)\n\nReturns\n\nDiscreteNonParametric: Discrete distribution with support determined by the method parameter\n\nDetails\n\nThis method computes probability masses directly using the interval boundaries. For each interval [a, b], the probability is computed as cdf(dist, b) - cdf(dist, a). The resulting probabilities are normalized to sum to 1.\n\nExamples\n\nusing Distributions, DiscretizeDistributions, IntervalArithmetic\n\n# Create intervals manually\nintervals = [interval(-1.0, 0.0), interval(0.0, 1.0), interval(1.0, 2.0)]\n\n# Discretize using these intervals with different methods\nnormal_dist = Normal(0, 1)\ndiscrete_intervals = discretize(normal_dist, intervals)                      # Intervals\ndiscrete_centered = discretize(normal_dist, intervals; method=:centred)      # Midpoints\ndiscrete_left = discretize(normal_dist, intervals; method=:left_aligned)     # Left endpoints\n\n# Each method gives the same probabilities but different support representations\n\n\n\n\n\n","category":"function"},{"location":"#DiscretizeDistributions.left_align_distribution","page":"Discretize Distributions.jl","title":"DiscretizeDistributions.left_align_distribution","text":"left_align_distribution(dist::Distributions.DiscreteNonParametric{IntervalArithmetic.Interval{T}, ...})\n\nConvert an interval-based discrete distribution to a left-aligned point-based distribution.\n\nThis function takes a discrete distribution with interval support and creates a new distribution where each support point is positioned at the left endpoint (infimum) of the corresponding interval. Infinite intervals are automatically removed before conversion.\n\nArguments\n\ndist::DiscreteNonParametric{Interval{T}, ...}: Input discrete distribution with interval support\n\nReturns\n\nDiscreteNonParametric{T, ...}: New distribution with left-aligned point support\n\nExamples\n\nusing Distributions, DiscretizeDistributions, IntervalArithmetic\n\n# Create an interval-based distribution\nintervals = [interval(0.0, 1.0), interval(1.0, 2.0), interval(2.0, 3.0)]\nprobs = [0.3, 0.4, 0.3]\ninterval_dist = DiscreteNonParametric(intervals, probs, check_args=false)\n\n# Convert to left-aligned points\nleft_aligned = left_align_distribution(interval_dist)\n# Support becomes [0.0, 1.0, 2.0] (left endpoints of intervals)\n\n\n\n\n\n","category":"function"},{"location":"#DiscretizeDistributions.centred_distribution","page":"Discretize Distributions.jl","title":"DiscretizeDistributions.centred_distribution","text":"centred_distribution(dist::Distributions.DiscreteNonParametric{IntervalArithmetic.Interval{T}, ...})\n\nConvert an interval-based discrete distribution to a centered point-based distribution.\n\nThis function takes a discrete distribution with interval support and creates a new distribution where each support point is positioned at the center (midpoint) of the corresponding interval. Infinite intervals are automatically removed before conversion.\n\nArguments\n\ndist::DiscreteNonParametric{Interval{T}, ...}: Input discrete distribution with interval support\n\nReturns\n\nDiscreteNonParametric{T, ...}: New distribution with centered point support\n\nExamples\n\nusing Distributions, DiscretizeDistributions, IntervalArithmetic\n\n# Create an interval-based distribution\nintervals = [interval(0.0, 1.0), interval(1.0, 2.0), interval(2.0, 3.0)]\nprobs = [0.3, 0.4, 0.3]\ninterval_dist = DiscreteNonParametric(intervals, probs, check_args=false)\n\n# Convert to centered points\ncentered = centred_distribution(interval_dist)\n# Support becomes [0.5, 1.5, 2.5] (midpoints of intervals)\n\n\n\n\n\n","category":"function"},{"location":"#DiscretizeDistributions.right_align_distribution","page":"Discretize Distributions.jl","title":"DiscretizeDistributions.right_align_distribution","text":"right_align_distribution(dist::Distributions.DiscreteNonParametric{IntervalArithmetic.Interval{T}, ...})\n\nConvert an interval-based discrete distribution to a right-aligned point-based distribution.\n\nThis function takes a discrete distribution with interval support and creates a new distribution where each support point is positioned at the right endpoint (supremum) of the corresponding interval. Infinite intervals are automatically removed before conversion.\n\nArguments\n\ndist::DiscreteNonParametric{Interval{T}, ...}: Input discrete distribution with interval support\n\nReturns\n\nDiscreteNonParametric{T, ...}: New distribution with right-aligned point support\n\nExamples\n\nusing Distributions, DiscretizeDistributions, IntervalArithmetic\n\n# Create an interval-based distribution\nintervals = [interval(0.0, 1.0), interval(1.0, 2.0), interval(2.0, 3.0)]\nprobs = [0.3, 0.4, 0.3]\ninterval_dist = DiscreteNonParametric(intervals, probs, check_args=false)\n\n# Convert to right-aligned points\nright_aligned = right_align_distribution(interval_dist)\n# Support becomes [1.0, 2.0, 3.0] (right endpoints of intervals)\n\n\n\n\n\n","category":"function"},{"location":"double_censoring/#Double-Censoring","page":"Double Censoring","title":"Double Censoring","text":"","category":"section"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"The motivation for this package is simplifying the simulation of continuous waiting time distributions in discrete time. For example say I have some complex dynamic model where after event A occurs there we know in the real world mathrmGamma(31 21) is a good approximation for the time until event B occurs.","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"If I am running this model in discrete time with a relative time step of 0.1, I can use the following code to simulate this:","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"using DiscreteDistributions, Distributions, Random\n\ncontinuous_waiting_time = truncated(Gamma(3.1, 2.1), upper = 20.0) #advisable to bound the distribution or manually trim tails (will be some [x, ∞) interval)])\n\ntime_step = 1//1\ndiscrete_waiting_time = discretize(continuous_waiting_time, time_step, method = :left_aligned)\ndiscrete_waiting_time.support ./= time_step","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"Then discretewaitingtime can be used to simulate the number of discrete steps until the event occurs, with each x  mathrmdiscrete_waiting_time representing that the event occurs in the interval x x + 1)","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"This approximates the continuous distribution well (after adjusting for left-alignment of the intervals): (Image: Figure showing a histogram of samples from discrete_waiting_time against the pdf of the continuous distribution)","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"Comparing summary values:","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"Summary Continuous Distribution Discrete Approximation\nMean 6.5 6.5\nMedian 5.87 5.5\nVariance 12.23 12.32","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"Double censoring accounts for the idea that the time of event A (or another subsequent event is also censored this way). See these slides for a write up of this concept and the importance of account for it when estimating delay distributions. CensoredDistributions.jl is a Julia implementation of this concept.","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"However DiscretizeDistributions is not intended for estimating/fitting the discretized distributions, rather it is a convenient wrapper for simulation from a fixed or known distribution. If we have event C that occurs after B with distribution mathrmGamma(31 21) we can simulate this again like so:","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"continuous_waiting_time_two = truncated(Gamma(3.1, 2.1), lower = 1, upper = 100)\n\ndiscrete_waiting_time_two = discretize(continuous_waiting_time_two, time_step, method = :left_aligned)\ndiscrete_waiting_time_two.support ./= time_step","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"This also approximates the continuous distribution reasonably well (after adjusting for left-alignment of the intervals): (Image: Figure showing a histogram of samples from discrete_waiting_time and discrete_waiting_time_two compared to the histogram of the two continuous distributions)","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"Comparing summary values:","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"Summary Continuous Distribution Discrete Approximation\nMean 13.06 13.09\nMedian 12.43 12.0\nVariance 25.64 25.8","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"Hence I don't think double censoring matters that much for the use case of this package. We do end with the differences in the Medians and the in general the discrete approximation is slightly skewed to the right. A solution to this would be to try to discretize over both distributions and their convolution, but this hasn't been implemented yet.","category":"page"},{"location":"double_censoring/","page":"Double Censoring","title":"Double Censoring","text":"See examples/double_censoring.jl for the script behind this analysis.","category":"page"}]
}
